<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving
and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">

<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">

<front>
<journal-meta>
<journal-id></journal-id>

<journal-title-group>
<journal-title>Journal Name</journal-title>
</journal-title-group>
<issn></issn>

<publisher>
<publisher-name></publisher-name>
</publisher>
</journal-meta>


<article-meta>


<title-group>
<article-title>Karst feature characterization to identify locations for
opportunistic recharge enhancement in Arizona</article-title>
</title-group>

<contrib-group>
<contrib contrib-type="author" corresp="yes">
<contrib-id contrib-id-type="orcid">0000-0002-5352-7215</contrib-id>
<name>
<surname>Lima</surname>
<given-names>Ryan E.</given-names>
</name>
<string-name>Ryan E. Lima</string-name>
<degrees>PhD</degrees>
<email>ryan.lima@nau.edu</email>
<role vocab="https://credit.niso.org" vocab-term="investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation/">Investigation</role>
<role vocab="https://credit.niso.org" vocab-term="software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software/">Software</role>
<role vocab="https://credit.niso.org" vocab-term="visualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/visualization/">Visualization</role>
<xref ref-type="aff" rid="aff-1">a</xref>
<xref ref-type="aff" rid="aff-2">b</xref>
<xref ref-type="aff" rid="aff-3">c</xref>
<xref ref-type="corresp" rid="cor-1">&#x002A;</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Springer</surname>
<given-names>Abraham E.</given-names>
</name>
<string-name>Abraham E. Springer</string-name>
<degrees>PhD</degrees>
<xref ref-type="aff" rid="aff-1">a</xref>
<xref ref-type="aff" rid="aff-3">c</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Sankey</surname>
<given-names>Temuulen Tsagaan</given-names>
</name>
<string-name>Temuulen Tsagaan Sankey</string-name>
<degrees>PhD</degrees>
<xref ref-type="aff" rid="aff-1">a</xref>
<xref ref-type="aff" rid="aff-2">b</xref>
</contrib>
</contrib-group>
<aff id="aff-1">
<institution-wrap>
<institution>Northern Arizona University</institution>
</institution-wrap>







</aff>
<aff id="aff-2">
<institution-wrap>
<institution>School of Informatics, Computing &amp; Cyber
Systems</institution>
</institution-wrap>







</aff>
<aff id="aff-3">
<institution-wrap>
<institution>School of Earth and Sustainability</institution>
</institution-wrap>







</aff>
<author-notes>
<corresp id="cor-1">ryan.lima@nau.edu</corresp>
</author-notes>

<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-08-28">
<year>2024</year>
<month>8</month>
<day>28</day>
</pub-date>







<history></history>


<abstract>
<p>This research utlizes remote sensing and GIS to characterize karst
surface features and map areas suitable for opportunistic groundwater
recharge enhancement in the State of Arizona</p>
</abstract>
<kwd-group kwd-group-type="author">
<kwd>Karst</kwd>
<kwd>Recharge</kwd>
<kwd>Arizona</kwd>
<kwd>Opportunistic Recharge Enhancement</kwd>
</kwd-group>




</article-meta>

</front>

<body>
<sec id="introduction">
  <title>1 Introduction</title>
</sec>
<sec id="sec-data-methods">
  <title>2 Data &amp; Methods</title>
</sec>
<sec id="conclusion">
  <title>3 Conclusion</title>
</sec>
<sec id="references">
  <title>References</title>
</sec>
</body>

<back>
</back>

<sub-article article-type="notebook" id="nb-3-nb-1">
<front-stub>
<title-group>
<article-title>White Box Tools testing</article-title>
</title-group>
</front-stub>

<body>
<sec id="e0e1f94d-9e7f-4dbe-b6a3-630cb1e8276c-nb-1" specific-use="notebook-content">
<code language="python">'''
!pip install -U whitebox
!pip install whitebox-workflows
!pip install rasterio matplotlib plotly
!pip install geopandas
!pip install cartopy
!pip install geodatasets
!pip install folium rioxarray earthpy
'''


</code>
<boxed-text>
  <preformat>'\n!pip install -U whitebox\n!pip install whitebox-workflows\n!pip install rasterio matplotlib plotly\n!pip install geopandas\n!pip install cartopy\n!pip install geodatasets\n!pip install folium rioxarray earthpy\n'</preformat>
</boxed-text>
</sec>
<sec id="cell-33b8eb23-f802-4d2f-b286-1633304f50ed-nb-1" specific-use="notebook-content">
<code language="python">import whitebox
from whitebox_workflows import WbEnvironment

wbe = WbEnvironment()
print(wbe.version()) # Print the version number</code>
<boxed-text>
  <preformat>Whitebox Workflows for Python v1.3.1 by Whitebox Geospatial Inc. 
Developed by Dr. John B. Lindsay, (c) 2022-2024

Description:
Whitebox Workflows for Python is an advanced geospatial data analysis platform 
and Python extension module.</preformat>
</boxed-text>
</sec>
<sec id="cell-8f4c2934-8ab2-497d-b542-8a2877756ac5-nb-1" specific-use="notebook-content">
<code language="python">wbt = whitebox.WhiteboxTools()</code>
</sec>
<sec id="cell-748316f2-0708-43a3-b8c3-c7d952e8db92-nb-1" specific-use="notebook-content">
<code language="python">wbe.verbose = True
wbe.working_directory = r'G:\Github\ATUR-KARST-DATA\data\rasters'
print(f'Working directory has been set to: {wbe.working_directory}')
</code>
<boxed-text>
  <preformat>Working directory has been set to: G:\Github\ATUR-KARST-DATA\data\rasters\</preformat>
</boxed-text>
</sec>
<sec id="ba12ea79-1465-4001-b93e-c23d66b9f81d-nb-1" specific-use="notebook-content">
<p>Lets create a simple function to plot rastesr stored in our working
directory</p>
</sec>
<sec id="cell-6070805b-edb0-488f-b229-24eaaaf3daed-nb-1" specific-use="notebook-content">
<code language="python">import rasterio
from matplotlib import pyplot as plt
from rasterio.plot import show
from mpl_toolkits.axes_grid1 import make_axes_locatable
import geopandas as gpd
from shapely.geometry import box


def plot_single_raster(raster_path, title=None, cmap='gray'):
    &quot;&quot;&quot;
    Plots a single raster.

    Parameters:
        raster_path (str): File path to the raster file.
        title (str): Title for the plot (optional).
        cmap (str): Colormap to use for the plot (default is 'gray').
    &quot;&quot;&quot;
    # Open the raster file
    with rasterio.open(raster_path) as src:
        raster_data = src.read(1)  # Read the first band

    # Plot the raster
    plt.figure(figsize=(10, 10))
    plt.imshow(raster_data, cmap=cmap)
    if title:
        plt.title(title)
    plt.colorbar(label='Value')
    plt.axis('off')  # Optionally turn off axis labels
    plt.show()

# Example usage
raster_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\DEM1m.tif'

# Call the function with a title and a custom colormap
plot_single_raster(raster_file, title=&quot;DEM (1m Resolution)&quot;, cmap='viridis')</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-6-output-1.png" />
</boxed-text>
</sec>
<sec id="cell-39fedb9d-fa04-428d-898e-2aaaea7464f3-nb-1" specific-use="notebook-content">
<p>Next lets actually see where this raster is located and get the
projection information.</p>
</sec>
<sec id="e382c260-9c45-483a-a378-850461ba9b5c-nb-1" specific-use="notebook-content">
<code language="python">import os
import folium
import rioxarray as rxr
import numpy as np
from skimage import exposure
from matplotlib import cm
import matplotlib
from folium.raster_layers import ImageOverlay
from folium import Map, LayerControl

def plot_raster_interactive(raster_path, title=None, dst_crs='EPSG:4326'):
    &quot;&quot;&quot;
    Plots a single raster over an interactive map using Folium.

    Parameters:
        raster_path (str): File path to the raster file.
        title (str): Title for the plot (optional).
        dst_crs (str): Destination coordinate reference system for reprojecting the raster (default is 'EPSG:4326').
    &quot;&quot;&quot;
    # Open the raster in rioxarray
    img = rxr.open_rasterio(raster_path, masked=True)

    # Reproject the raster to be the correct CRS
    img = img.rio.reproject(dst_crs)

    # Replace all null values with the minimum value in the array
    img_plot = img.where(~img.isnull(), img.min())

    # Scale the array from 0 to 255 for visualization using skimage
    scaled_img = exposure.rescale_intensity(img_plot.values[0], out_range=(0, 255)).astype(np.uint8)

    # Get the bounds for the image overlay
    bounds = [[img.rio.bounds()[1], img.rio.bounds()[0]], [img.rio.bounds()[3], img.rio.bounds()[2]]]

    # Access the colormap using the older method
    #cmap = cm.get_cmap('terrain')
    cmap = matplotlib.colormaps['terrain']
    norm_scaled_img = cmap(scaled_img / 255.0)

    # Create the map centered on the raster
    m = Map(location=[np.mean([bounds[0][0], bounds[1][0]]), np.mean([bounds[0][1], bounds[1][1]])], zoom_start=13)

    # Convert the scaled image to an RGB array for overlay
    scaled_img_rgb = np.dstack([norm_scaled_img[:, :, i] for i in range(3)])

    # Add the raster as an overlay to the map
    ImageOverlay(image=scaled_img_rgb, bounds=bounds, opacity=0.6, interactive=True, cross_origin=False, zindex=1).add_to(m)

    # Add layer control
    LayerControl().add_to(m)

    # Display the map
    return m

# Example usage
raster_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\DEM1m.tif'

# Call the function and display the interactive map
interactive_map = plot_raster_interactive(raster_file, title=&quot;DEM (1m Resolution)&quot;)
interactive_map
</code>
<boxed-text>
  <preformat>C:\Users\rylim\anaconda3\Lib\site-packages\paramiko\transport.py:219: CryptographyDeprecationWarning: Blowfish has been deprecated and will be removed in a future release
  &quot;class&quot;: algorithms.Blowfish,</preformat>
</boxed-text>
<boxed-text>
  <preformat>&lt;folium.folium.Map at 0x2350904c610&gt;</preformat>
</boxed-text>
</sec>
<sec id="cell-9f3bd0cf-cbb3-4e7b-93e6-747bf501a0eb-nb-1" specific-use="notebook-content">
<p>Next lets create a multidimentional hillshade using whitebox
tools</p>
</sec>
<sec id="cell-409e6cc2-d0ed-4573-b783-0dfdaf80974a-nb-1" specific-use="notebook-content">
<code language="python">raster_file = 'DEM1m.tif'
dem = wbe.read_raster(raster_file) # we call the raster in with white box tools rather than rasterio here</code>
</sec>
<sec id="cell-697b9f17-71ce-4405-bc02-17c06a13a8c4-nb-1" specific-use="notebook-content">
<code language="python">hs = wbe.multidirectional_hillshade(dem)
wbe.write_raster(hs, 'hillshade.tif', compress=False) # Compression is good, but it is a bit slower so here we won't use it.

hillshade_file = wbe.working_directory + os.sep + 'hillshade.tif'
#print(hillshade_file)
plot_single_raster(hillshade_file, title=&quot;DEM (1m Resolution)&quot;, cmap='grey')</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-9-output-1.png" />
</boxed-text>
</sec>
<sec id="d4261083-aa86-413d-87e5-d91ee3f7bf1f-nb-1" specific-use="notebook-content">
<code language="python"># now lets smooth the DEM
dem_smoothed = wbe.feature_preserving_smoothing(dem, filter_size=11, normal_diff_threshold=25.0, iterations=3)
wbe.write_raster(dem_smoothed, 'dem_smoothed.tif', compress=False)
hs = wbe.multidirectional_hillshade(dem_smoothed)
wbe.write_raster(hs, 'hillshade_smoothed.tif', compress=False) 

</code>
</sec>
<sec id="cdf38d3a-9724-4d46-a4cf-9216850f82ef-nb-1" specific-use="notebook-content">
<code language="python">def plot_two_rasters_side_by_side(raster_path_1, raster_path_2, title_1=None, title_2=None, cmap='gray'):
    &quot;&quot;&quot;
    Plots two rasters side by side for comparison.

    Parameters:
        raster_path_1 (str): File path to the first raster file.
        raster_path_2 (str): File path to the second raster file.
        title_1 (str): Title for the first subplot (optional).
        title_2 (str): Title for the second subplot (optional).
        cmap (str): Colormap to use for the plots (default is 'gray').
    &quot;&quot;&quot;
    # Open the first raster file
    with rasterio.open(raster_path_1) as src1:
        raster_data_1 = src1.read(1)
    
    # Open the second raster file
    with rasterio.open(raster_path_2) as src2:
        raster_data_2 = src2.read(1)
    
    # Create the subplots
    fig, axes = plt.subplots(1, 2, figsize=(15, 7))

    # Plot the first raster
    axes[0].imshow(raster_data_1, cmap=cmap)
    if title_1:
        axes[0].set_title(title_1)
    axes[0].axis('off')  # Turn off axis labels
    
    # Plot the second raster
    axes[1].imshow(raster_data_2, cmap=cmap)
    if title_2:
        axes[1].set_title(title_2)
    axes[1].axis('off')  # Turn off axis labels

    # Display the plots
    plt.show()

# Example usage after generating the hillshades
hillshade_file_unsmoothed = wbe.working_directory + os.sep + 'hillshade.tif'
hillshade_file_smoothed = wbe.working_directory + os.sep + 'hillshade_smoothed.tif'

plot_two_rasters_side_by_side(
    hillshade_file_unsmoothed, 
    hillshade_file_smoothed, 
    title_1=&quot;Unsmoothed Hillshade&quot;, 
    title_2=&quot;Smoothed Hillshade&quot;, 
    cmap='grey'
)</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-11-output-1.png" />
</boxed-text>
</sec>
<sec id="cell-20889ebd-d8ea-4020-99bd-fe51b5023a40-nb-1" specific-use="notebook-content">
<code language="python">contours = wbe.contours_from_raster(dem_smoothed, contour_interval=10.0)
# Define the full path to save the contours shapefile
vector_directory = r&quot;C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors&quot;
contours_path = os.path.join(vector_directory, 'contours.shp')


# Write the vector to the specified path
wbe.write_vector(contours, contours_path)</code>
</sec>
<sec id="bb31f499-d66c-4b1e-9262-8184ccb0d9c6-nb-1" specific-use="notebook-content">
<code language="python">hillshade_file_smoothed = r'G:\Github\ATUR-KARST-DATA\data\rasters\hillshade_smoothed.tif'
contours_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\contours.shp'

# Load the smoothed hillshade raster
with rasterio.open(hillshade_file_smoothed) as src:
    hillshade_data = src.read(1)
    hillshade_extent = [src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top]

# Load the contours
contours = gpd.read_file(contours_file)

# Plot the hillshade
plt.figure(figsize=(10, 10))
plt.imshow(hillshade_data, cmap='gray', extent=hillshade_extent)

# Overlay the contours
contours.plot(ax=plt.gca(), color='red', linewidth=1)

# Add title and display the plot
plt.title('Smoothed Hillshade with Contours')
plt.axis('off')
plt.show()</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-13-output-1.png" />
</boxed-text>
</sec>
<sec id="cell-04665f78-235a-4799-a4bd-5c6498210d65-nb-1" specific-use="notebook-content">
<code language="python">import math
import rasterio
import geopandas as gpd
import matplotlib.pyplot as plt

# Remove depressions by first breaching the depressions and then filling the remaining depressions
dem_no_deps = wbe.breach_depressions_least_cost(dem_smoothed, flat_increment=0.001, max_dist=100)  # Adjust max_dist as needed
dem_no_deps = wbe.fill_depressions(dem_no_deps, flat_increment=0.001)

# Perform a flow-accumulation operation using the Qin (2007) multiple flow direction algorithm
channel_threshold = 10000.0
flow_accum = wbe.qin_flow_accumulation(dem_no_deps, out_type='cells', convergence_threshold=channel_threshold, log_transform=True)
flow_accum_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\qin_flow_accum.tif'
wbe.write_raster(flow_accum, flow_accum_file)

# Map the streams by thresholding the flow accumulation raster
streams = flow_accum &gt; math.log(channel_threshold)
streams_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\streams.tif'
wbe.write_raster(streams, streams_file)

# Load the flow accumulation raster for plotting
with rasterio.open(flow_accum_file) as src:
    flow_accum_data = src.read(1)
    flow_accum_extent = [src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top]

# Plot the flow accumulation raster
plt.figure(figsize=(10, 10))
plt.imshow(flow_accum_data, cmap='viridis', extent=flow_accum_extent)
plt.colorbar(label='Flow Accumulation (log-transformed)')
plt.title('Flow Accumulation (Qin 2007)')
plt.axis('off')
plt.show()

# Load the streams raster for plotting
with rasterio.open(streams_file) as src:
    streams_data = src.read(1)
    streams_extent = [src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top]

# Plot the streams raster
plt.figure(figsize=(10, 10))
plt.imshow(streams_data, cmap='Blues', extent=streams_extent)
plt.title('Streams')
plt.axis('off')
plt.show()
</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-14-output-1.png" />
</boxed-text>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-14-output-2.png" />
</boxed-text>
</sec>
<sec id="cell-4cc547ab-350c-40b4-b4b1-4a136023fbca-nb-1" specific-use="notebook-content">
<code language="python">import rasterio
import geopandas as gpd
from shapely.geometry import LineString
from skimage import measure
import numpy as np

# Step 1: Save the WhiteboxTools raster to a file
streams_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\streams.tif'
wbe.write_raster(streams, streams_file)

# Step 2: Load the DEM or flow accumulation raster to get CRS and transform
dem_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\DEM1m.tif'  # Replace with the path to your original DEM or flow accumulation file
with rasterio.open(dem_file) as src:
    dem_crs = src.crs
    dem_transform = src.transform

# Step 3: Read the saved streams raster using Rasterio
with rasterio.open(streams_file) as src:
    streams_array = src.read(1)  # Read the first band as a NumPy array
    transform = src.transform
    crs = src.crs

# Step 4: Find contours in the binary image
contours = measure.find_contours(streams_array, 0.5)

# Step 5: Convert the contours to shapely LineString objects
stream_lines = []
for contour in contours:
    # Convert raster coordinates to spatial coordinates
    spatial_contour = [rasterio.transform.xy(transform, y, x) for y, x in contour]
    stream_lines.append(LineString(spatial_contour))

# Step 6: Create a GeoDataFrame with the LineStrings
gdf = gpd.GeoDataFrame(geometry=stream_lines, crs=crs)

# Step 7: Save the vector streams as a shapefile
streams_vector_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\streams.shp'
gdf.to_file(streams_vector_file)
</code>
</sec>
<sec id="a6753609-e9e9-4361-822f-a68d851e97c9-nb-1" specific-use="notebook-content">
<code language="python">import numpy as np
import os
import rasterio

# We need a d8-pointer raster to be able to route flow through the network
d8_pntr = wbe.d8_pointer(dem_no_deps)

# Use the basins tool to delineate drainage basins
basins = wbe.basins(d8_pntr)
wbe.write_raster(basins, r'G:\Github\ATUR-KARST-DATA\data\rasters\basins.tif')

# Paths to the existing streams and basins rasters
basins_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\basins.tif'
streams_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\streams.tif'

# Load the streams raster
with rasterio.open(streams_file) as src_streams:
    streams_array = src_streams.read(1)
    streams_extent = [src_streams.bounds.left, src_streams.bounds.right, src_streams.bounds.bottom, src_streams.bounds.top]

# Load the basins raster
with rasterio.open(basins_file) as src_basins:
    basins_array = src_basins.read(1)
    basins_extent = [src_basins.bounds.left, src_basins.bounds.right, src_basins.bounds.bottom, src_basins.bounds.top]

# Intersect streams with basin boundaries to find potential pour points
pour_points_array = (streams_array &gt; 0) &amp; (streams_array != basins_array)

# Convert the boolean array to uint8 (0 or 1)
pour_points_array_uint8 = pour_points_array.astype(np.uint8)

# Save pour points as a raster
pour_points_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\pour_points.tif'
with rasterio.open(
    pour_points_file,
    'w',
    driver='GTiff',
    height=pour_points_array_uint8.shape[0],
    width=pour_points_array_uint8.shape[1],
    count=1,
    dtype=pour_points_array_uint8.dtype,
    crs=src_streams.crs,
    transform=src_streams.transform,
) as dst:
    dst.write(pour_points_array_uint8, 1)


</code>
</sec>
<sec id="cell-8f9b6fd4-76c5-4cac-ab50-a8775c28b6fc-nb-1" specific-use="notebook-content">
<code language="python"># Convert the raster to vector points
pour_points_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\pour_points.tif'
outlet_shapefile = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\outlet.shp'

# Convert the raster to vector points
wbt.raster_to_vector_points(
    i=pour_points_file,
    output=outlet_shapefile
)</code>
<boxed-text>
  <preformat>.\whitebox_tools.exe --run=&quot;RasterToVectorPoints&quot; --input='G:\Github\ATUR-KARST-DATA\data\rasters\pour_points.tif' --output='C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\outlet.shp' -v --compress_rasters=False

***********************************
* Welcome to RasterToVectorPoints *
* Powered by WhiteboxTools        *
* www.whiteboxgeo.com             *
***********************************
Reading data...
Progress: 0%
Progress: 1%
Progress: 2%
Progress: 3%
Progress: 4%
Progress: 5%
Progress: 6%
Progress: 7%
Progress: 8%
Progress: 9%
Progress: 10%
Progress: 11%
Progress: 12%
Progress: 13%
Progress: 14%
Progress: 15%
Progress: 16%
Progress: 17%
Progress: 18%
Progress: 19%
Progress: 20%
Progress: 21%
Progress: 22%
Progress: 23%
Progress: 24%
Progress: 25%
Progress: 26%
Progress: 27%
Progress: 28%
Progress: 29%
Progress: 30%
Progress: 31%
Progress: 32%
Progress: 33%
Progress: 34%
Progress: 35%
Progress: 36%
Progress: 37%
Progress: 38%
Progress: 39%
Progress: 40%
Progress: 41%
Progress: 42%
Progress: 43%
Progress: 44%
Progress: 45%
Progress: 46%
Progress: 47%
Progress: 48%
Progress: 49%
Progress: 50%
Progress: 51%
Progress: 52%
Progress: 53%
Progress: 54%
Progress: 55%
Progress: 56%
Progress: 57%
Progress: 58%
Progress: 59%
Progress: 60%
Progress: 61%
Progress: 62%
Progress: 63%
Progress: 64%
Progress: 65%
Progress: 66%
Progress: 67%
Progress: 68%
Progress: 69%
Progress: 70%
Progress: 71%
Progress: 72%
Progress: 73%
Progress: 74%
Progress: 75%
Progress: 76%
Progress: 77%
Progress: 78%
Progress: 79%
Progress: 80%
Progress: 81%
Progress: 82%
Progress: 83%
Progress: 84%
Progress: 85%
Progress: 86%
Progress: 87%
Progress: 88%
Progress: 89%
Progress: 90%
Progress: 91%
Progress: 92%
Progress: 93%
Progress: 94%
Progress: 95%
Progress: 96%
Progress: 97%
Progress: 98%
Progress: 99%
Progress: 100%
Saving data...
Output file written
Elapsed Time (excluding I/O): 0.96s</preformat>
</boxed-text>
<boxed-text>
  <preformat>0</preformat>
</boxed-text>
</sec>
<sec id="cell-4806291f-808c-4036-ad3d-380dc9fddc4f-nb-1" specific-use="notebook-content">
<code language="python">

# Let's extract the watershed for a specific outlet point
outlet = wbe.read_vector(outlet_shapefile) # This is a vector point that was included when we downloaded the `mill_brook` dataset.

# Make sure that the outlet is positioned along the stream
outlet = wbe.jenson_snap_pour_points(outlet, streams, 5.0)</code>
</sec>
<sec id="cell-3014594c-be34-403b-8574-e70bdde17d8e-nb-1" specific-use="notebook-content">
<code language="python">import rasterio
import geopandas as gpd
import matplotlib.pyplot as plt

# Define file paths
hillshade_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\hillshade_smoothed.tif'
contacts_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\Contacts.shp'
faults_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\Faults.shp'
study_area_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\LakeMaryStudyArea_Bound.shp'
streams_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\streams.shp'
roads_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\Roads_All.shp'
#outlets_file = r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\outlet.shp'

# Load the hillshade raster
with rasterio.open(hillshade_file) as src:
    hillshade = src.read(1)
    hillshade_extent = [src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top]

# Load the shapefiles
contacts = gpd.read_file(contacts_file)
faults = gpd.read_file(faults_file)
study_area = gpd.read_file(study_area_file)
streams = gpd.read_file(streams_file)
roads = gpd.read_file(roads_file)
#outlets = gpd.read_file(outlets_file)

# Plot the hillshade and shapefiles
plt.figure(figsize=(12, 12))

# Plot the hillshade raster
plt.imshow(hillshade, cmap='gray', extent=hillshade_extent)

# Plot the shapefiles
contacts.plot(ax=plt.gca(), color='blue', linewidth=1, label='Contacts')
faults.plot(ax=plt.gca(), color='red', linewidth=1, label='Faults')
study_area.plot(ax=plt.gca(), color='none', edgecolor='green', linewidth=2, label='Lake Mary Study Area')
streams.plot(ax=plt.gca(), color='cyan', linewidth=1, label='Streams')
roads.plot(ax=plt.gca(), color='yellow', linewidth=1, label='Roads')

# Plot outlets as stars
#outlets.plot(ax=plt.gca(), color='black', marker='*', markersize=100, label='Outlets')

# Add a legend
plt.legend()

# Add title and labels
plt.title('Smoothed Hillshade with Geospatial Features')
plt.xlabel('Longitude')
plt.ylabel('Latitude')

# Show the plot
plt.show()</code>
<boxed-text>
  <preformat>C:\Users\rylim\AppData\Local\Temp\ipykernel_17892\2381821653.py:44: UserWarning: Legend does not support handles for PatchCollection instances.
See: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler
  plt.legend()</preformat>
</boxed-text>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-19-output-2.png" />
</boxed-text>
</sec>
<sec id="cell-5156b36a-e3a9-4308-9f15-754975b17eff-nb-1" specific-use="notebook-content">
<code language="python">import numpy as np
import rasterio
from scipy.ndimage import convolve
import matplotlib.pyplot as plt

def create_directional_filters(kernel_size):
    &quot;&quot;&quot;
    Creates vertical and horizontal directional filters of a given kernel size.
    
    Args:
        kernel_size (int): The size of the kernel. Must be an odd number.
        
    Returns:
        vertical_filter (ndarray): The vertical filter.
        horizontal_filter (ndarray): The horizontal filter.
    &quot;&quot;&quot;
    if kernel_size % 2 == 0:
        raise ValueError(&quot;Kernel size must be an odd number.&quot;)
    
    center = kernel_size // 2
    
    vertical_filter = np.zeros((kernel_size, kernel_size))
    horizontal_filter = np.zeros((kernel_size, kernel_size))
    
    vertical_filter[:, center] = np.concatenate([np.ones(center), [0], -np.ones(center)])
    horizontal_filter[center, :] = np.concatenate([np.ones(center), [0], -np.ones(center)])
    
    return vertical_filter, horizontal_filter

def enhance_contrast(image, gamma=1.0):
    &quot;&quot;&quot;
    Enhances the contrast of an image using a power-law (gamma) transformation.
    
    Args:
        image (ndarray): The input image.
        gamma (float): The gamma value for contrast enhancement.
        
    Returns:
        contrast_enhanced_image (ndarray): The contrast-enhanced image.
    &quot;&quot;&quot;
    # Normalize the image to the range [0, 1]
    image_normalized = image - np.min(image)
    image_normalized = image_normalized / np.max(image_normalized)
    
    # Apply the gamma correction
    contrast_enhanced_image = np.power(image_normalized, gamma)
    
    # Scale back to original range
    contrast_enhanced_image = contrast_enhanced_image * np.max(image)
    
    return contrast_enhanced_image

def apply_and_plot_filters(hillshade_array, transform, kernel_sizes, gamma=1.0):
    &quot;&quot;&quot;
    Applies vertical and horizontal directional filters of different kernel sizes
    to a DEM, optionally enhances the contrast, and plots the results for comparison.
    
    Args:
        hillshade_array (ndarray): The hillshade array.
        transform (Affine): The affine transformation for plotting.
        kernel_sizes (list): A list of kernel sizes to apply.
        gamma (float): The gamma value for contrast enhancement. Default is 1.0 (no enhancement).
    &quot;&quot;&quot;
    fig, axes = plt.subplots(len(kernel_sizes), 2, figsize=(12, len(kernel_sizes) * 6))
    
    for i, kernel_size in enumerate(kernel_sizes):
        vertical_filter, horizontal_filter = create_directional_filters(kernel_size)
        
        filtered_vertical = convolve(hillshade_array, vertical_filter)
        filtered_horizontal = convolve(hillshade_array, horizontal_filter)
        
        # Apply contrast enhancement if gamma is not 1.0
        if gamma != 1.0:
            filtered_vertical = enhance_contrast(filtered_vertical, gamma=gamma)
            filtered_horizontal = enhance_contrast(filtered_horizontal, gamma=gamma)
        
        axes[i, 0].imshow(filtered_vertical, cmap='gray', extent=(transform[2], transform[2] + hillshade_array.shape[1] * transform[0],
                                                                  transform[5] + hillshade_array.shape[0] * transform[4], transform[5]))
        axes[i, 0].set_title(f'Vertical Filter ({kernel_size}x{kernel_size})')
        axes[i, 0].axis('off')
        
        axes[i, 1].imshow(filtered_horizontal, cmap='gray', extent=(transform[2], transform[2] + hillshade_array.shape[1] * transform[0],
                                                                    transform[5] + hillshade_array.shape[0] * transform[4], transform[5]))
        axes[i, 1].set_title(f'Horizontal Filter ({kernel_size}x{kernel_size})')
        axes[i, 1].axis('off')
    
    plt.tight_layout()
    plt.show()</code>
</sec>
<sec id="efe2b8c8-9d16-4449-987b-004eb9e103de-nb-1" specific-use="notebook-content">
<code language="python">
# Load the multi-directional hillshade raster
hillshade_file = r'G:\Github\ATUR-KARST-DATA\data\rasters\hillshade_smoothed.tif'
with rasterio.open(hillshade_file) as src:
    hillshade_array = src.read(1)  # Load the hillshade as a NumPy array
    transform = src.transform
    crs = src.crs


# Apply and plot filters with kernel sizes of 3x3, 5x5, 7x7, and 9x9, with contrast enhancement
kernel_sizes = [5, 7, 9, 11]
apply_and_plot_filters(hillshade_array, transform, kernel_sizes, gamma=2)  # Adjust gamma to enhance contrast</code>
<boxed-text>
  <graphic mimetype="image" mime-subtype="png" xlink:href="data-screening_files/figure-jats/cell-21-output-1.png" />
</boxed-text>
</sec>
<sec id="cell-342b5b7e-41c8-4634-a195-f2c9617a458d-nb-1" specific-use="notebook-content">
<code language="python">'''
# Find contours in the Canny edges
contours = measure.find_contours(edges_canny_contrast, 0.5)

# Convert contours to a list of (x, y) coordinates
contour_lines = []
for contour in contours:
    spatial_contour = [rasterio.transform.xy(transform, y, x) for y, x in contour]
    contour_lines.append(spatial_contour)

# Step 1: Plot Canny edges with contours overlaid
fig, ax = plt.subplots(1, 2, figsize=(18, 10))

ax[0].imshow(edges_canny, cmap='viridis')
for contour in contour_lines:
    ax[0].plot([pt[0] for pt in contour], [pt[1] for pt in contour], linewidth=2, color='red')
ax[0].set_title('Canny Edge Detection with Contours')
ax[0].axis('off')


# Plot the hillshade with roads, contacts, faults, streams overlaid
ax[1].imshow(hillshade_array, cmap='gray', extent=(transform[2], transform[2] + hillshade_array.shape[1] * transform[0],
                                                   transform[5] + hillshade_array.shape[0] * transform[4], transform[5]))

contacts.plot(ax=ax[1], color='blue', linewidth=1, label='Contacts')
faults.plot(ax=ax[1], color='red', linewidth=1, label='Faults')
streams.plot(ax=ax[1], color='cyan', linewidth=1, label='Streams')
roads.plot(ax=ax[1], color='yellow', linewidth=1, label='Roads')

ax[1].set_title('Hillshade with Geospatial Features')
ax[1].axis('off')

# Add a legend to the second plot
legend_patches = [
    mpatches.Patch(color='blue', label='Contacts'),
    mpatches.Patch(color='red', label='Faults'),
    mpatches.Patch(color='cyan', label='Streams'),
    mpatches.Patch(color='yellow', label='Roads')
]
ax[1].legend(handles=legend_patches, loc='upper right')

plt.tight_layout()
plt.show()
'''</code>
<boxed-text>
  <preformat>&quot;\n# Find contours in the Canny edges\ncontours = measure.find_contours(edges_canny_contrast, 0.5)\n\n# Convert contours to a list of (x, y) coordinates\ncontour_lines = []\nfor contour in contours:\n    spatial_contour = [rasterio.transform.xy(transform, y, x) for y, x in contour]\n    contour_lines.append(spatial_contour)\n\n# Step 1: Plot Canny edges with contours overlaid\nfig, ax = plt.subplots(1, 2, figsize=(18, 10))\n\nax[0].imshow(edges_canny, cmap='viridis')\nfor contour in contour_lines:\n    ax[0].plot([pt[0] for pt in contour], [pt[1] for pt in contour], linewidth=2, color='red')\nax[0].set_title('Canny Edge Detection with Contours')\nax[0].axis('off')\n\n\n# Plot the hillshade with roads, contacts, faults, streams overlaid\nax[1].imshow(hillshade_array, cmap='gray', extent=(transform[2], transform[2] + hillshade_array.shape[1] * transform[0],\n                                                   transform[5] + hillshade_array.shape[0] * transform[4], transform[5]))\n\ncontacts.plot(ax=ax[1], color='blue', linewidth=1, label='Contacts')\nfaults.plot(ax=ax[1], color='red', linewidth=1, label='Faults')\nstreams.plot(ax=ax[1], color='cyan', linewidth=1, label='Streams')\nroads.plot(ax=ax[1], color='yellow', linewidth=1, label='Roads')\n\nax[1].set_title('Hillshade with Geospatial Features')\nax[1].axis('off')\n\n# Add a legend to the second plot\nlegend_patches = [\n    mpatches.Patch(color='blue', label='Contacts'),\n    mpatches.Patch(color='red', label='Faults'),\n    mpatches.Patch(color='cyan', label='Streams'),\n    mpatches.Patch(color='yellow', label='Roads')\n]\nax[1].legend(handles=legend_patches, loc='upper right')\n\nplt.tight_layout()\nplt.show()\n&quot;</preformat>
</boxed-text>
</sec>
<sec id="cell-479b32a1-ac97-481e-932c-5c507a8aabf6-nb-1" specific-use="notebook-content">
<code language="python">
# Step 4: Spatial analysis - find intersections
intersections_contacts = gpd.overlay(lineaments_gdf, contacts, how='intersection')
intersections_faults = gpd.overlay(lineaments_gdf, faults, how='intersection')
intersections_streams = gpd.overlay(lineaments_gdf, streams, how='intersection')
intersections_roads = gpd.overlay(lineaments_gdf, roads, how='intersection')

# Print the number of intersections
print(f&quot;Number of lineaments coinciding with contacts: {len(intersections_contacts)}&quot;)
print(f&quot;Number of lineaments coinciding with faults: {len(intersections_faults)}&quot;)
print(f&quot;Number of lineaments coinciding with streams: {len(intersections_streams)}&quot;)
print(f&quot;Number of lineaments coinciding with roads: {len(intersections_roads)}&quot;)

# Save intersection results as shapefiles if needed
intersections_contacts.to_file(r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\intersections_contacts.shp')
intersections_faults.to_file(r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\intersections_faults.shp')
intersections_streams.to_file(r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\intersections_streams.shp')
intersections_roads.to_file(r'C:\Users\rylim\Documents\GitHub\ATUR-KARST\data\vectors\intersections_roads.shp')
</code>
<boxed-text>
  <preformat>SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 830-831: truncated \UXXXXXXXX escape (4290465348.py, line 19)
[1;36m  Cell [1;32mIn[62], line 19[1;36m[0m
[1;33m    '''[0m
[1;37m       ^[0m
[1;31mSyntaxError[0m[1;31m:[0m (unicode error) 'unicodeescape' codec can't decode bytes in position 830-831: truncated \UXXXXXXXX escape</preformat>
</boxed-text>
</sec>
</body>



<back>
</back>


</sub-article>

</article>